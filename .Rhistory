inWarn <- tryCatch(as.logical(warnNotFound), error = function(err) {
warning("error encountered processing warning parameter so treating it as FALSE: ", err)
FALSE
})
if(length(inWarn) <= 0) {
warning("warning parameter has zero length so treating it as FALSE")
inWarn <- FALSE
}
if(is.na(inWarn)) {
warning("warning parameter has NA value so treating it as FALSE")
inWarn <- FALSE
}
# Retrieve the nimble arguments
nimbleArgs <- list(
nimbleModel = formals(nimble::nimbleModel),
configureMCMC = formals(nimble::configureMCMC),
compileNimble = formals(nimble::compileNimble),
runMCMC = formals(nimble::runMCMC)
)
# Retrieve the arguments provided to the function
# Doing this while avoiding the arguments being evaluated is weird (see here https://stackoverflow.com/questions/70602963/ellipsis-as-function-in-substitute)
inputArgs <- eval(substitute(alist(...)))
if(length(inputArgs) > 0) {
argNames <- names(inputArgs)
if(!is.null(argNames)) {
# Give the parameters some names based on their deparsed values if they don't already have one
names(argNames) <- sapply(X = inputArgs, FUN = function(curLang) { deparse1(curLang) })
}
# If the list has any elements that have the same names as the composite functions then
# format them so that are of the form "function." notation
argMatchesSpecifiedFunc <- argNames %in% names(nimbleArgs)
if(any(argMatchesSpecifiedFunc)) {
inputArgs <- c(inputArgs[!argMatchesSpecifiedFunc], do.call(c, lapply(X = names(nimbleArgs), FUN = function(curSubName, inputArgs) {
outList <- list()
if(curSubName %in% names(inputArgs)) {
outList <- inputArgs[[curSubName]]
# Retrieve the names for the elements
if(is.null(names(outList))) {
names(outList) <- paste(curSubName, sapply(X = outList, FUN = function(curLang) {
deparse1(curLang)
}), sep = ".")
} else {
names(outList) <- paste(curSubName, names(outList), sep = ".")
}
}
outList
}, inputArgs = inputArgs)))
}
# Determine which of the input arguments has the "function." notation
isSpecifiedFunc <- apply(X = sapply(X = names(nimbleArgs), FUN = function(curFunction, argNames) {
grepl(paste0("^", curFunction, "\\."), argNames, perl = TRUE)
}, argNames = argNames, simplify = "array"), MARGIN = 2, FUN = any)
if(any(isSpecifiedFunc)) {
# Go through each of the set of arguments for the function and find element specifically tailored for them through the "function." notation
nimbleArgs <- lapply(X = names(nimbleArgs), FUN = function(curFunction, inputArgs, nimbleArgs) {
# Initialise an output list with the default values
outList <- nimbleArgs[[curFunction]]
# Retrieve the argument names defined to be part of the currently applied function through the "function." notation
searchStr <- paste0("^", curFunction, "\\.")
curArgNames <- argNames[grepl(searchStr, names(inputArgs), perl = TRUE)]
if(length(curArgNames) > 0) {
# Copy those elements that already appear in the output list across from the input arguments
newArgNames <- gsub(searchStr, "", curArgNames)
isInOutList <- names(outList) %in% newArgNames
outList[isInOutList] <- inputArgs[curArgNames[isInOutList]]
if(any(!isInOutList)) {
# If there are any left over arguments not in the output list then add them to the end
outList <- append(outList, inputArgs[curArgNames[!isInOutList]])
}
}
if("..." %in% names(outList)) {
# Remove the ellipsis argument from the output list
outList <- outList[names(outList) != "..."]
}
outList
}, inputArgs = inputArgs[isSpecifiedFunc], nimbleArgs = nimbleArgs)
}
if(any(!isSpecifiedFunc)) {
# Process any arguments that do not have the "function." notation (and therefore may be used in multiple functions)
nimbleArgs <- lapply(X = nimbleArgs, FUN = function(curArgs, inputArgs) {
# Find which arguments that appear both in the provided arguments and the listed available arguments for the current function
sharedArgs <- names(curArgs)[names(curArgs) %in% names(inputArgs)]
outArgs <- curArgs
if(length(sharedArgs) > 0) {
# Copy those arguments across
outArgs[sharedArgs] <- inputArgs[sharedArgs]
}
outArgs
}, inputArgs = inputArgs[!isSpecifiedFunc])
if(inWarn) {
# Check to make sure that all given arguments are found in the constituent
# functions
isInFuncs <- sapply(X = names(inputArgs[!isSpecifiedFunc]), FUN = function(curInputArg, nimbleArgs) {
any(sapply(X = nimbleArgs, FUN = function(curNimble, curInputArg) {
curInputArg %in% names(curNimble)
}, curInputArg = curInputArg))
}, nimbleArgs = nimbleArgs)
if(any(!isInFuncs)) {
warning("some given arguments do not appear in NIMBLE constituent functions: ", paste(names(inputArgs[!isSpecifiedFunc])[!isInFuncs], collapse = " "))
}
}
}
}
nimbleArgs
}
nimbleParameters()
?requireNamespace
#'
#' @return A \code{list} with named elements corresponding to each of the constituent
#' NIMBLE functions.  Each of these elements is a \code{list} with named elements
#' corresponding to each of the constituent function arguments and the unevaluated
#' expression to be passed to those arguments
#'
#' @author Joseph D. Chipperfield, \email{joechip90@@googlemail.com}
#' @seealso \code{\link[nimble]{configureMCMC}}, \code{\link[nimble]{runMCMC}},
#' \code{\link[nimble]{nimbleModel}}, \code{\link[nimble]{compileNimble}}
#' @keywords internal
nimbleParameters <- function(..., warnNotFound = FALSE) {
# Sanity check the warning parameter
inWarn <- tryCatch(as.logical(warnNotFound), error = function(err) {
warning("error encountered processing warning parameter so treating it as FALSE: ", err)
FALSE
})
if(length(inWarn) <= 0) {
warning("warning parameter has zero length so treating it as FALSE")
inWarn <- FALSE
}
if(is.na(inWarn)) {
warning("warning parameter has NA value so treating it as FALSE")
inWarn <- FALSE
}
# Retrieve the nimble arguments
nimbleArgs <- list(
nimbleModel = formals(nimble::nimbleModel),
configureMCMC = formals(nimble::configureMCMC),
compileNimble = formals(nimble::compileNimble),
runMCMC = formals(nimble::runMCMC)
)
if(requireNamepace("INLA")) {
# If the INLA package is installed then also retrieve the arguments of the inla
nimbleArgs <- append(nimbleArgs, list(inla = formals(INLA::inla)))
}
# Retrieve the arguments provided to the function
# Doing this while avoiding the arguments being evaluated is weird (see here https://stackoverflow.com/questions/70602963/ellipsis-as-function-in-substitute)
inputArgs <- eval(substitute(alist(...)))
if(length(inputArgs) > 0) {
argNames <- names(inputArgs)
if(!is.null(argNames)) {
# Give the parameters some names based on their deparsed values if they don't already have one
names(argNames) <- sapply(X = inputArgs, FUN = function(curLang) { deparse1(curLang) })
}
# If the list has any elements that have the same names as the composite functions then
# format them so that are of the form "function." notation
argMatchesSpecifiedFunc <- argNames %in% names(nimbleArgs)
if(any(argMatchesSpecifiedFunc)) {
inputArgs <- c(inputArgs[!argMatchesSpecifiedFunc], do.call(c, lapply(X = names(nimbleArgs), FUN = function(curSubName, inputArgs) {
outList <- list()
if(curSubName %in% names(inputArgs)) {
outList <- inputArgs[[curSubName]]
# Retrieve the names for the elements
if(is.null(names(outList))) {
names(outList) <- paste(curSubName, sapply(X = outList, FUN = function(curLang) {
deparse1(curLang)
}), sep = ".")
} else {
names(outList) <- paste(curSubName, names(outList), sep = ".")
}
}
outList
}, inputArgs = inputArgs)))
}
# Determine which of the input arguments has the "function." notation
isSpecifiedFunc <- apply(X = sapply(X = names(nimbleArgs), FUN = function(curFunction, argNames) {
grepl(paste0("^", curFunction, "\\."), argNames, perl = TRUE)
}, argNames = argNames, simplify = "array"), MARGIN = 2, FUN = any)
if(any(isSpecifiedFunc)) {
# Go through each of the set of arguments for the function and find element specifically tailored for them through the "function." notation
nimbleArgs <- lapply(X = names(nimbleArgs), FUN = function(curFunction, inputArgs, nimbleArgs) {
# Initialise an output list with the default values
outList <- nimbleArgs[[curFunction]]
# Retrieve the argument names defined to be part of the currently applied function through the "function." notation
searchStr <- paste0("^", curFunction, "\\.")
curArgNames <- argNames[grepl(searchStr, names(inputArgs), perl = TRUE)]
if(length(curArgNames) > 0) {
# Copy those elements that already appear in the output list across from the input arguments
newArgNames <- gsub(searchStr, "", curArgNames)
isInOutList <- names(outList) %in% newArgNames
outList[isInOutList] <- inputArgs[curArgNames[isInOutList]]
if(any(!isInOutList)) {
# If there are any left over arguments not in the output list then add them to the end
outList <- append(outList, inputArgs[curArgNames[!isInOutList]])
if(!("..." %in% names(outList))) {
warning("extra arguments (", paste(curArgNames[!isInOutList], collapse = ", "), ") passed to a function (", curFunction, ") that does not include them in its ",
"function definition and for which there is no ... parameterisation")
}
}
}
if("..." %in% names(outList)) {
# Remove the ellipsis argument from the output list
outList <- outList[names(outList) != "..."]
}
outList
}, inputArgs = inputArgs[isSpecifiedFunc], nimbleArgs = nimbleArgs)
}
if(any(!isSpecifiedFunc)) {
# Process any arguments that do not have the "function." notation (and therefore may be used in multiple functions)
nimbleArgs <- lapply(X = nimbleArgs, FUN = function(curArgs, inputArgs) {
# Find which arguments that appear both in the provided arguments and the listed available arguments for the current function
sharedArgs <- names(curArgs)[names(curArgs) %in% names(inputArgs)]
outArgs <- curArgs
if(length(sharedArgs) > 0) {
# Copy those arguments across
outArgs[sharedArgs] <- inputArgs[sharedArgs]
}
outArgs
}, inputArgs = inputArgs[!isSpecifiedFunc])
if(inWarn) {
# Check to make sure that all given arguments are found in the constituent
# functions
isInFuncs <- sapply(X = names(inputArgs[!isSpecifiedFunc]), FUN = function(curInputArg, nimbleArgs) {
any(sapply(X = nimbleArgs, FUN = function(curNimble, curInputArg) {
curInputArg %in% names(curNimble)
}, curInputArg = curInputArg))
}, nimbleArgs = nimbleArgs)
if(any(!isInFuncs)) {
warning("some given arguments do not appear in NIMBLE constituent functions: ", paste(names(inputArgs[!isSpecifiedFunc])[!isInFuncs], collapse = " "))
}
}
}
}
# Remove any "..." parameters if they still exist in the output
setNames(lapply(X = nimbleArgs, FUN = function(curFunc) { curFunc[names(curFunc) != "..."] }), names(nimbleArgs))
}
nimbleParameters()
#'
#' @return A \code{list} with named elements corresponding to each of the constituent
#' NIMBLE functions.  Each of these elements is a \code{list} with named elements
#' corresponding to each of the constituent function arguments and the unevaluated
#' expression to be passed to those arguments
#'
#' @author Joseph D. Chipperfield, \email{joechip90@@googlemail.com}
#' @seealso \code{\link[nimble]{configureMCMC}}, \code{\link[nimble]{runMCMC}},
#' \code{\link[nimble]{nimbleModel}}, \code{\link[nimble]{compileNimble}}
#' @keywords internal
nimbleParameters <- function(..., warnNotFound = FALSE) {
# Sanity check the warning parameter
inWarn <- tryCatch(as.logical(warnNotFound), error = function(err) {
warning("error encountered processing warning parameter so treating it as FALSE: ", err)
FALSE
})
if(length(inWarn) <= 0) {
warning("warning parameter has zero length so treating it as FALSE")
inWarn <- FALSE
}
if(is.na(inWarn)) {
warning("warning parameter has NA value so treating it as FALSE")
inWarn <- FALSE
}
# Retrieve the nimble arguments
nimbleArgs <- list(
nimbleModel = formals(nimble::nimbleModel),
configureMCMC = formals(nimble::configureMCMC),
compileNimble = formals(nimble::compileNimble),
runMCMC = formals(nimble::runMCMC)
)
if(requireNamespace("INLA")) {
# If the INLA package is installed then also retrieve the arguments of the inla
nimbleArgs <- append(nimbleArgs, list(inla = formals(INLA::inla)))
}
# Retrieve the arguments provided to the function
# Doing this while avoiding the arguments being evaluated is weird (see here https://stackoverflow.com/questions/70602963/ellipsis-as-function-in-substitute)
inputArgs <- eval(substitute(alist(...)))
if(length(inputArgs) > 0) {
argNames <- names(inputArgs)
if(!is.null(argNames)) {
# Give the parameters some names based on their deparsed values if they don't already have one
names(argNames) <- sapply(X = inputArgs, FUN = function(curLang) { deparse1(curLang) })
}
# If the list has any elements that have the same names as the composite functions then
# format them so that are of the form "function." notation
argMatchesSpecifiedFunc <- argNames %in% names(nimbleArgs)
if(any(argMatchesSpecifiedFunc)) {
inputArgs <- c(inputArgs[!argMatchesSpecifiedFunc], do.call(c, lapply(X = names(nimbleArgs), FUN = function(curSubName, inputArgs) {
outList <- list()
if(curSubName %in% names(inputArgs)) {
outList <- inputArgs[[curSubName]]
# Retrieve the names for the elements
if(is.null(names(outList))) {
names(outList) <- paste(curSubName, sapply(X = outList, FUN = function(curLang) {
deparse1(curLang)
}), sep = ".")
} else {
names(outList) <- paste(curSubName, names(outList), sep = ".")
}
}
outList
}, inputArgs = inputArgs)))
}
# Determine which of the input arguments has the "function." notation
isSpecifiedFunc <- apply(X = sapply(X = names(nimbleArgs), FUN = function(curFunction, argNames) {
grepl(paste0("^", curFunction, "\\."), argNames, perl = TRUE)
}, argNames = argNames, simplify = "array"), MARGIN = 2, FUN = any)
if(any(isSpecifiedFunc)) {
# Go through each of the set of arguments for the function and find element specifically tailored for them through the "function." notation
nimbleArgs <- lapply(X = names(nimbleArgs), FUN = function(curFunction, inputArgs, nimbleArgs) {
# Initialise an output list with the default values
outList <- nimbleArgs[[curFunction]]
# Retrieve the argument names defined to be part of the currently applied function through the "function." notation
searchStr <- paste0("^", curFunction, "\\.")
curArgNames <- argNames[grepl(searchStr, names(inputArgs), perl = TRUE)]
if(length(curArgNames) > 0) {
# Copy those elements that already appear in the output list across from the input arguments
newArgNames <- gsub(searchStr, "", curArgNames)
isInOutList <- names(outList) %in% newArgNames
outList[isInOutList] <- inputArgs[curArgNames[isInOutList]]
if(any(!isInOutList)) {
# If there are any left over arguments not in the output list then add them to the end
outList <- append(outList, inputArgs[curArgNames[!isInOutList]])
if(!("..." %in% names(outList))) {
warning("extra arguments (", paste(curArgNames[!isInOutList], collapse = ", "), ") passed to a function (", curFunction, ") that does not include them in its ",
"function definition and for which there is no ... parameterisation")
}
}
}
if("..." %in% names(outList)) {
# Remove the ellipsis argument from the output list
outList <- outList[names(outList) != "..."]
}
outList
}, inputArgs = inputArgs[isSpecifiedFunc], nimbleArgs = nimbleArgs)
}
if(any(!isSpecifiedFunc)) {
# Process any arguments that do not have the "function." notation (and therefore may be used in multiple functions)
nimbleArgs <- lapply(X = nimbleArgs, FUN = function(curArgs, inputArgs) {
# Find which arguments that appear both in the provided arguments and the listed available arguments for the current function
sharedArgs <- names(curArgs)[names(curArgs) %in% names(inputArgs)]
outArgs <- curArgs
if(length(sharedArgs) > 0) {
# Copy those arguments across
outArgs[sharedArgs] <- inputArgs[sharedArgs]
}
outArgs
}, inputArgs = inputArgs[!isSpecifiedFunc])
if(inWarn) {
# Check to make sure that all given arguments are found in the constituent
# functions
isInFuncs <- sapply(X = names(inputArgs[!isSpecifiedFunc]), FUN = function(curInputArg, nimbleArgs) {
any(sapply(X = nimbleArgs, FUN = function(curNimble, curInputArg) {
curInputArg %in% names(curNimble)
}, curInputArg = curInputArg))
}, nimbleArgs = nimbleArgs)
if(any(!isInFuncs)) {
warning("some given arguments do not appear in NIMBLE constituent functions: ", paste(names(inputArgs[!isSpecifiedFunc])[!isInFuncs], collapse = " "))
}
}
}
}
# Remove any "..." parameters if they still exist in the output
setNames(lapply(X = nimbleArgs, FUN = function(curFunc) { curFunc[names(curFunc) != "..."] }), names(nimbleArgs))
}
nimbleParameters()
requireNamespace("INLA", quietly = TRUE)
#'
#' @return A \code{list} with named elements corresponding to each of the constituent
#' NIMBLE functions.  Each of these elements is a \code{list} with named elements
#' corresponding to each of the constituent function arguments and the unevaluated
#' expression to be passed to those arguments
#'
#' @author Joseph D. Chipperfield, \email{joechip90@@googlemail.com}
#' @seealso \code{\link[nimble]{configureMCMC}}, \code{\link[nimble]{runMCMC}},
#' \code{\link[nimble]{nimbleModel}}, \code{\link[nimble]{compileNimble}}
#' @keywords internal
nimbleParameters <- function(..., warnNotFound = FALSE) {
# Sanity check the warning parameter
inWarn <- tryCatch(as.logical(warnNotFound), error = function(err) {
warning("error encountered processing warning parameter so treating it as FALSE: ", err)
FALSE
})
if(length(inWarn) <= 0) {
warning("warning parameter has zero length so treating it as FALSE")
inWarn <- FALSE
}
if(is.na(inWarn)) {
warning("warning parameter has NA value so treating it as FALSE")
inWarn <- FALSE
}
# Retrieve the nimble arguments
nimbleArgs <- list(
nimbleModel = formals(nimble::nimbleModel),
configureMCMC = formals(nimble::configureMCMC),
compileNimble = formals(nimble::compileNimble),
runMCMC = formals(nimble::runMCMC)
)
if(requireNamespace("INLA", quietly = TRUE)) {
# If the INLA package is installed then also retrieve the arguments of the inla
nimbleArgs <- append(nimbleArgs, list(inla = formals(INLA::inla)))
}
# Retrieve the arguments provided to the function
# Doing this while avoiding the arguments being evaluated is weird (see here https://stackoverflow.com/questions/70602963/ellipsis-as-function-in-substitute)
inputArgs <- eval(substitute(alist(...)))
if(length(inputArgs) > 0) {
argNames <- names(inputArgs)
if(!is.null(argNames)) {
# Give the parameters some names based on their deparsed values if they don't already have one
names(argNames) <- sapply(X = inputArgs, FUN = function(curLang) { deparse1(curLang) })
}
# If the list has any elements that have the same names as the composite functions then
# format them so that are of the form "function." notation
argMatchesSpecifiedFunc <- argNames %in% names(nimbleArgs)
if(any(argMatchesSpecifiedFunc)) {
inputArgs <- c(inputArgs[!argMatchesSpecifiedFunc], do.call(c, lapply(X = names(nimbleArgs), FUN = function(curSubName, inputArgs) {
outList <- list()
if(curSubName %in% names(inputArgs)) {
outList <- inputArgs[[curSubName]]
# Retrieve the names for the elements
if(is.null(names(outList))) {
names(outList) <- paste(curSubName, sapply(X = outList, FUN = function(curLang) {
deparse1(curLang)
}), sep = ".")
} else {
names(outList) <- paste(curSubName, names(outList), sep = ".")
}
}
outList
}, inputArgs = inputArgs)))
}
# Determine which of the input arguments has the "function." notation
isSpecifiedFunc <- apply(X = sapply(X = names(nimbleArgs), FUN = function(curFunction, argNames) {
grepl(paste0("^", curFunction, "\\."), argNames, perl = TRUE)
}, argNames = argNames, simplify = "array"), MARGIN = 2, FUN = any)
if(any(isSpecifiedFunc)) {
# Go through each of the set of arguments for the function and find element specifically tailored for them through the "function." notation
nimbleArgs <- lapply(X = names(nimbleArgs), FUN = function(curFunction, inputArgs, nimbleArgs) {
# Initialise an output list with the default values
outList <- nimbleArgs[[curFunction]]
# Retrieve the argument names defined to be part of the currently applied function through the "function." notation
searchStr <- paste0("^", curFunction, "\\.")
curArgNames <- argNames[grepl(searchStr, names(inputArgs), perl = TRUE)]
if(length(curArgNames) > 0) {
# Copy those elements that already appear in the output list across from the input arguments
newArgNames <- gsub(searchStr, "", curArgNames)
isInOutList <- names(outList) %in% newArgNames
outList[isInOutList] <- inputArgs[curArgNames[isInOutList]]
if(any(!isInOutList)) {
# If there are any left over arguments not in the output list then add them to the end
outList <- append(outList, inputArgs[curArgNames[!isInOutList]])
if(!("..." %in% names(outList))) {
warning("extra arguments (", paste(curArgNames[!isInOutList], collapse = ", "), ") passed to a function (", curFunction, ") that does not include them in its ",
"function definition and for which there is no ... parameterisation")
}
}
}
if("..." %in% names(outList)) {
# Remove the ellipsis argument from the output list
outList <- outList[names(outList) != "..."]
}
outList
}, inputArgs = inputArgs[isSpecifiedFunc], nimbleArgs = nimbleArgs)
}
if(any(!isSpecifiedFunc)) {
# Process any arguments that do not have the "function." notation (and therefore may be used in multiple functions)
nimbleArgs <- lapply(X = nimbleArgs, FUN = function(curArgs, inputArgs) {
# Find which arguments that appear both in the provided arguments and the listed available arguments for the current function
sharedArgs <- names(curArgs)[names(curArgs) %in% names(inputArgs)]
outArgs <- curArgs
if(length(sharedArgs) > 0) {
# Copy those arguments across
outArgs[sharedArgs] <- inputArgs[sharedArgs]
}
outArgs
}, inputArgs = inputArgs[!isSpecifiedFunc])
if(inWarn) {
# Check to make sure that all given arguments are found in the constituent
# functions
isInFuncs <- sapply(X = names(inputArgs[!isSpecifiedFunc]), FUN = function(curInputArg, nimbleArgs) {
any(sapply(X = nimbleArgs, FUN = function(curNimble, curInputArg) {
curInputArg %in% names(curNimble)
}, curInputArg = curInputArg))
}, nimbleArgs = nimbleArgs)
if(any(!isInFuncs)) {
warning("some given arguments do not appear in NIMBLE constituent functions: ", paste(names(inputArgs[!isSpecifiedFunc])[!isInFuncs], collapse = " "))
}
}
}
}
# Remove any "..." parameters if they still exist in the output
setNames(lapply(X = nimbleArgs, FUN = function(curFunc) { curFunc[names(curFunc) != "..."] }), names(nimbleArgs))
}
nimbleParameters()
xVals <- 1:100
yValsBad <- floor(rnorm(length(xVals), mean = 200 - xVals, sd = 40))
plot(xVals, yValsBad)
yValsBad <- floor(rnorm(length(xVals), mean = 200 - xVals, sd = 30))
plot(xVals, yValsBad)
plot(xVals, yValsBad, xlab = "Species 1", ylab = "Species 2")
yValsGood <- floor(rnorm(length(xVals), mean = 200 - xVals, sd = 101 - xVals))
plot(xVals, yValsGood, xlab = "Species 1", ylab = "Sprecies 2")
?abline
plot(xVals, yValsBad, xlab = "Species 1", ylab = "Species 2")
abline(coef = c(200, -1))
plot(xVals, yValsGood, xlab = "Species 1", ylab = "Sprecies 2")
abline(coef = c(200, -1))
plot(xVals, yValsBad, xlab = "Species 1", ylab = "Species 2")
abline(coef = c(200, -1))
plot(xVals, yValsBad, xlab = "Species 1", ylab = "Species 2", ylim = range(yValsBad, yValsGood))
abline(coef = c(200, -1))
plot(xVals, yValsGood, xlab = "Species 1", ylab = "Sprecies 2", ylim = range(yValsBad, yValsGood))
abline(coef = c(200, -1))
plot(xVals, yValsBad, xlab = "Species 1", ylab = "Species 2", ylim = range(yValsBad, yValsGood))
abline(coef = c(200, -1))
plot(xVals, yValsGood, xlab = "Species 1", ylab = "Sprecies 2", ylim = range(yValsBad, yValsGood))
abline(coef = c(200, -1))
